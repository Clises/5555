[{"title":"js设计模式","url":"/2018/05/19/js高级/","content":"# 设计模式\n## 设计模式之单例模式\n保证一个类只有一个实例  <br/>\n实现方法：先判断实例是否存在，如果存在就直接返回，如果不存在就创建了再返回，以确保一个类只有一个实例对象。<br/>\n在js中，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。。。\n打个比方说：我买了一套房子，我去实地看房，有钥匙的话我直接开门进去，如果没有钥匙，我就得去找开发商去找钥匙，这套房子我有所有权，我就是这个实例，也代表这个实例存在。所谓的命名空间就是我，因为这间房子归属于我自己。从全局命名空间里提供给一个唯一的访问点来访问该对象，在整栋楼房中，有很户主跟我同姓，需要在之中找到对应的楼层，门牌号来访问我。\n## indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。\n    实例：\n## parseInt() 函数可解析一个字符串，并返回一个整数。\n\n## js中的函数\n  ### 立即执行函数\n\n```js\n\n/*函数声明*/\nfunction name() {\n    \n}\n    /*函数表达式*/\n    var name=function () {\n        \n    }\n    /*匿名函数*/\n    function() {\n        \n    }\n/*函数声明和函数表达式的区别*/\n    /*\n    * 函数声明需要js代码解析到当前这行才可以调用\n    * 函数表达式后加()可以立即执行调用，函数声明不可以，只能以name()调用\n    * */\n    /********举例子*******/\n    fName();\n    function fName(){...}//正确，函数声明提升，所以 fName()可以写在函数声明之前。\n\n    fName();\n    var fName=function(){...}//错误，函数表达式不具备函数声明提升。\n\n    var fName=function(){...}();//正确，函数表达式后边加()立即调用函数。\n\n    function fName(){...}();//错误，函数声明必须用fName()调用。\n    //这行代码被解析为两部分： 1函数声明 function fName(){...}, 2分组表达式(),这表达式有误，因为括号内没有表达式，\n\n    function (){...}();//匿名函数不可以这么调用，因为function(){...}被当做了声明，声明不可以直接()调用。\n    //立即执行函数\n\n    /*\n    *常见写法:\n    * (function(){...})()\n      (function(){...}())\n    *\n    * */\n var aa=function() {\n            var a='';\n            for (var b=0;b<10;b++){\n                a+=b;\n            }\n            return a;\n        }()\n    console.log(aa)\n\n```\n\n\n# 数据类型\n## 字符串\n\n在字符串中可以使用\\作为转义字符，当表示一些特殊符号时可以使用\\进行转义\n\" 表示\"\n' 表示' \n\\t 制表符 \n\\n表示换行 \n但是现在需要打印:\n\"\\\"可以去自己转义自己输出<br/>\n\n## number\n\n不要用js计算精确度要求比较高的元素，整数基本没问题\n"},{"title":"html5 css3相关知识","url":"/2018/05/19/html5 css3相关/","content":"## CSS3 text-overflow 属性<br/>\n**规定当文本溢出包含元素时发生的情况<br/>**\n**可用在制作信息列表中**\n\n```html\n必须项：overflow：hideen\n属性值：text-overflow:ellipsis  修剪文本。\t\n        text-overflow:clip  显示省略符号来代表被修剪的文本。\t\n        string：使用给定的字符串来代表被修剪的文本。\t\n<!DOCTYPE html>\n<html>\n<head>\n<style> \ndiv.test\n{\nwhite-space:nowrap; \nwidth:12em; \noverflow:hidden; \nborder:1px solid #000000;\n}\n</style>\n</head>\n<body>\n\n<p>下面两个 div 包含无法在框中容纳的长文本。正如您所见，文本被修剪了。</p>\n\n<p>这个 div 使用 \"text-overflow:ellipsis\" ：</p>\n\n<div class=\"test\" style=\"text-overflow:ellipsis;\">This is some long text that will not fit in the box</div>\n\n<p>这个 div 使用 \"text-overflow:clip\"：</p>\n\n<div class=\"test\" style=\"text-overflow:clip;\">This is some long text that will not fit in the box</div>\n\n</body>\n</html>\n```\n属性值包括:\n    ![image](https://raw.githubusercontent.com/Clises/pic/master/text-overflow.png)\n\n# box-orient\n**该属性规定框的子元素应该被水平或垂直排列。**\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style> \ndiv\n{\nwidth:350px;\nheight:150px;\nborder:1px solid black;\n  \n/* Firefox */\ndisplay:-moz-box;\n-moz-box-orient:horizontal;\n\n/* Safari, Opera, and Chrome */\ndisplay:-webkit-box;\n-webkit-box-orient:horizontal;\n\n/* W3C */\ndisplay:box;\nbox-orient:horizontal;  //从左向右排列子元素\n}\n</style>\n</head>\n<body>\n\n<div>\n<p>段落 1。</p>\n<p>段落 2。</p>\n<p>段落 3。</p>\n</div>\n\n<p><b>注释：</b>IE 不支持 box-orient 属性。</p>\n\n</body>\n</html>\n```\n属性值包括:\n![image](https://github.com/Clises/pic/blob/master/box-orient.png?raw=true)\n\n# align-items\n定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。\n![image](https://github.com/Clises/pic/blob/master/align-items.jpg?raw=true)\n\n## >子元素选择器 <br/>\n选某元素的子元素的元素，如果一组div包含很多子元素，包括p  span\n要选择span 就直接div>span，空格可以不注意。。\n\n## border属性\n    dashed虚线\n    \n    \n## background-origin\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        div{\n\n            /* 关键样式 */\n            background: url(https://github.com/Clises/pic/blob/master/icon/like/Combined%20Shape%20Copy%203.png?raw=true)\n            no-repeat bottom right #58a;\n            background-origin: content-box;  /*相对于内荣框定位*/\n            background-origin: border-box;\n            /*相对于边框盒定位*/\n            background-origin: padding-box;\n/*相对于内边距框定位*/\n            padding: 10px 20px;\n            /* 其它样式 */\n            max-width: 10em;\n            min-height: 5em;\n            font: 100%/1 sans-serif;\n\n\n        }\n    </style>\n    <title>Title</title>\n</head>\n<body>\n<div>\n    兼容性问题解决方案\n</div>\n<p>\n    实现要点：\n    background-origin 默认值是 padding-box，也就说我们设置 background 为 top left 时左上角是 padding box（内边距的外沿框）的左上角。\n    在本例中设置 background-origin 为 content-box，那么就相对于 content box（内容区的外沿框）的左上角，那么也就是背景图离容器的右边和底边的偏移量是跟着容器的 padding 值走了，那设置 padding: 10px 20px; 自然就可以实现本例的效果了。\n</p>\n</body>\n</html>\n\n```\n##CSS3 box-sizing 属性\n\n  在设置box-sizing浏览器会以怪异模式进行解析，在这样的情况下，设置padding或者border之后不div不会错位掉下来。\n\n## button美化\nhttp://www.css88.com/demo/beautify-input/\n\n## img标签注意事项   实际用途:\nimg标签是inline，表现上更加倾向于inline-block，效果等同于块状元素。\n它的特殊表现包括：可以设置width/height;\n默认的，img元素在屏幕占据的空间与其图片的实际像素一致，除非CSS有设置或者自身的width/height HTML 属性有设置\n如果img标签的包裹元素为也为inline元素，则img的边界可以超出其直接父元素的边界，直到自己的宽、高达到最大或者设定值为止，而且文档流中img的兄弟元素也不能遮盖住img。最常见的就是<a>里面包含的<img>\n## vertical-align 属性 \n设置元素的垂直对齐方式<br/>\n属性值包括：\nhttp://www.w3school.com.cn/cssref/pr_pos_vertical-align.asp<br/>\n只在inline-block上其起作用，常用的属性值是middle\n\n## 多个块状元素一行显示\n- 1、两个块级元素都进行浮动。   注意清除浮动问题。\n- 2、两个块级元素都设置为display:inline-block行内块。\n- 3、进行flex布局,若有多个块状元素包含在div中，只需要设置父元素的display：flex就可以。。\n- 4、两个块级元素同时进行绝对定位，定位到同一高度。\n## linear-gradient()滤镜属性\n参考链接\n            http://www.css88.com/book/css/values/image/linear-gradient().html\n## css两端对齐方式\n    text-align：justify\n    column多列布局\n    使用justify-content:space-between\n\n\n  \n## opacity:0、visibility：hidden、display：none 三者区别\nopacity：0仅仅不可见，但仍可被浏览器发现，也就能触发各种事件。通过浏览器调试工具即可得出此结论。\nvisibility：hidden则相当于完全从文档流中删除了该元素，但所占据的尺寸仍然保留。\ndisplay：none 完全不在文档流中\n一定注意这个opacity，如果制作弹窗的话，如果只顾弹窗效果，而使用opcity会造成不必要的后果。。。。。\n\ndisplay:none和visibility:hidden的差别:visibility:hidden隐藏，但在浏览时保留位置；而CSS display:none视为不存在。\n\n###  如果在background中设置二维码，会无法扫描，应设置在元素中，在实际开发中，设计添加照片，不需要多余设置div的宽高。\n\n## 居中方式，x轴方向\n\n transform：translateX(50%);\n  position:absolute;\n  left:50%\n### font-weight  属性   用来设置文字粗细水平\n        默认值:normal\n        继承值：yes\n![image](https://github.com/Clises/pic/blob/master/font-weight.png?raw=true)\n### p标签中不能包含块状元素，若包含块状元素，会结束自己\n## html中a链接跳转失效方法\n```html\n<a href=\"javascript:void (0)\">\n  表示跳转失效\n</a>\n```\n"},{"title":"hexo使用","url":"/2018/05/19/hexo相关使用/","content":"## 安装Git\n前往Git官网下载相关版本压缩包，下载完成后解压安装。\n## 安装Node.js\n前往Node.js官方下载网站，下载Node.js官方安装包，下载完成后同样解压安装。\n## 安装Hexo\n到目前为止，安装Hexo所需要的环境已将安装完成，下一步只需要安装Hexo便可以了。\n点击鼠标右键，看是否有Git bash Here选项。如果没有可以前往Git安装根目录，启动git-base.exe也可以。\n在命令行中输入：\n```html\n$ npm install -g hexo-cli\n```\n### 创建Hexo文件夹\n找到想要放置博客的文件夹，比如（F:\\Hexo），在该目录下鼠标右击打开Gitbash工具，（右键菜单中没有该选项的可以用cmd命令cd等进入该文件夹）。执行下面的语句，会在F:\\Hexo文件夹下创建node_modules文件夹：\n```html\n$ hexo init\n```\n这里init后面可以跟文件目录，比如我想在F:\\Hexo下创建博客文件夹，那么可以用下面的命令：\n```html\n$ hexo init F:\\Hexo\n```\n### 安装依赖包\n\n在Hexo目录下，执行以下命令，你会发现F:\\Hexo\\node_modules目录下多了好多文件夹\n\n```html\n$ npm install\n```\n### 本地调试\n目前为止，已经搭建好自己的Hexo博客了，但是只能在本机上查看。执行以下两个命令（在F:\\Hexo目录下），然后在浏览器中输入 localhost:4000 就可以看到自己的博客了\n\n```html\n$ hexo generate \n$ hexo server\n```\n### 如何部署到github账户之上\n注册github账户，新建一个repository仓库，对应名字是gitzhaoyang.github.io\n#### 将本地的文件部署（上传）到Github账户中\n编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码（在你修改时，把 gitzhaoyang 要替换成你自己的用户名）\n```html\ndeploy:\n    type: git\n    repository: http://github.com/Gitzhaoyang/gitzhaoyang.github.io.git\n    branch: master\n\n```\n.yml文件对格式规范要求很严格，type: repository: branch: 前面有两个空格，冒号后面都有一个空格。\n\n执行以下指令即可完成部署（如果提示错误，可以看下面注意）：\n\n```html\n$ hexo generate\n$ hexo deploy\n```\n最后进行本地调试即可。\n\n\n"},{"title":"jquery","url":"/2018/05/19/jquery/","content":"## jQuery outerHeight() 方法\n定义：返回元素的高度，包括padding和border\n实例：在制作瀑布流中，使用outerHeight来返回整个容器的高度，图片与图片之间不会出现缝隙。\n## scrollTop() \n 设置 <div> 元素中滚动条的垂直偏移：\n 实例：可做滚动触发;回顶部\n## 实现jq瀑布流的思想\n## 一些数组的相关操作\nconcat  用于连接两个或者多个数组\npush在数组的末尾添加元素\nshift()  删除数组的第一个元素，并返回该元素\n\n## 以动态创建对象形式遍历json字符串\n  思路：创建对象，aa={bb:[]}\n  json 遍历方法总结\n \n## 现在css和js滚动指南\n\n## attr()设置或者返回被选元素的属性值   \n    设置属性值语法：$(selector).attr(attribute,value)\n\n## empty（）删除节点元素，但是只会删除节点元素的值，不会删除整个节点，可用来解决再次点击重新获取，以免覆盖。。\n\n## jq动态添加动向到event对象中\n   实例： $('e').on('click',{bol:flase})\n## append()和html()区别<br/>\nappend()是在html追加一些元素，而html()是替换html中的元素。<br/>\n如果在获取后台一组数据并进行遍历进行数据渲染，如果用html()只会获取一个组数据\n\n### 、解决jquery中动态新增的元素节点无法触发事件问题的两种方法\n\n(1)使用live函数\n$('.liLabel').live('click', function(){\n alert('OK');\n});<br/>\n(2)使用on函数,通过on方法绑定事件，可以绑定到它的父级或者body中<br/>\n```html\n$(\"#ulLabel\").on('click','.liLabel',function(){\n alert('OK')\n});\n或者：\n$(\"body\").on('click','.liLabel',function(){\n alert('OK')\n});\n```"},{"title":"前端发展简史","url":"/2018/05/19/前端发展简史/","content":"# 从静态走向动态\n  1994年可以看做前端历史的起点，这一年10月13日网景推出了第一版Navigator；这一年，Tim Berners-Lee创建了W3C；这一年，Tim的基友发布了CSS。还是这一年，为动态web网页设计的服务端脚本PHP以及笔者本人诞生。\n ![Alt text](../img/1.png)\n        万维网（WWW）是欧洲核子研究组织的一帮科学家为了方便看文档、传论文而创造的，这就是为什么Web网页都基于Document。Document就是用标记语言+超链接写成的由文字和图片构成的HTML页面，这样的功能已经完全满足学术交流的需要，所以网页的早期形态和Document一样，完全基于HTML页面，并且所有内容都是静态的。\n \n   随着网页从学术机构走向公众社会，网页承载的功能便超出了学术范围而变得愈加丰富，因此早期网页的局限性也逐渐显露出来。\n \n   第一，所有的网页都基于HTML页面，因为没有任何手段可以控制局部内容的显示和隐藏，因此任何局部的变化哪怕只多出一个标点符号，都只能重新下载一个新的页面。\n \n   第二，计算任务只能在服务端实现。由于网速限制，与服务器通信的过程是非常缓慢的，并且此过程是同步阻塞的，于是会出现这样的场景：用户提交一个表单，然后整个页面消失，浏览器呈现白屏，经过漫长的等待，浏览器渲染出一个和之前一模一样的页面，只不过输入框旁边多了一排红色小字：用户名错误。\n \n   第三，所有页面都是静态的，这意味着一个电商网站有一千种商品，哪怕页面布局一模一样，也必须写一千个单独的页面。\n \n   早期网页形态低下的效率是无法仅仅通过提高网速解决的。\n \n   1994年一个叫Rasmus Lerdorf的加拿大人为了维护个人网站而创建了PHP。PHP原意是Personal Home Page，宣传语是Hypertext Preprocessor（超文本处理者）。PHP实现了与数据库的交互以及用于生产动态页面的模板引擎，是Web领域中最主流的服务端语言。\n \n   1995年网景推出了JavaScript，实现了客户端的计算任务（如表单验证）。\n \n   1996年微软推出了iframe标签，实现了异步的局部加载。\n \n   1999年W3C发布第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，随即各大浏览器厂商模仿实现了XMLHttpRequest。这标识着Ajax的诞生，但是Ajax这个词是在六年后问世的，特别是在谷歌使用Ajax技术打造了Gmail和谷歌地图之后，Ajax获得了巨大的关注。Ajax是Web网页迈向Web应用的关键技术，它标识着Web2.0时代的到来。\n \n   2006年，XMLHttpRequest被W3C正式纳入标准。\n \n   至此，早期的Document终于进化为了Web page，上述三个局限都得到了妥善的解决。\n  ![Alt text](../img/3.png)\n  # 从后端走向前端\n    \n   早期的网页开发是由后端主导的，前端能做的也就是操作一下DOM。2006年John Resig发布了jQuery，jQuery主要用于操作DOM，其优雅的语法、符合直觉的事件驱动型的编程思维使其极易上手，因此很快风靡全球，大量基于jQuery的插件构成了一个庞大的生态系统，更加稳固了jQuery作为JS库一哥的地位。\n\n  jQuery最早的版本在这里：\n\n  http://genius.it/ejohn.org/files/jquery-original.html\n\n   起初制约Web开发从后到前的因素很简单，就是前端很多事干不了或干不好，当时的浏览器性能弱，标准化程度低。特别是占据大量市场份额的IE，不仅ugly，并且buggy。\n\n   于2008年问世的谷歌V8引擎改变了这一局面。现代浏览器的崛起终结了微软的垄断时代，前端的计算能力一下子变得过剩了。标准组织也非常配合的在2009年发布了第五代JavaScript，前端的装备得到了整体性的提高，前端界如同改革开放走进了一个令人目不暇接的新时代。\n\n   2009年AngularJS诞生，随后被谷歌收购。2010年backbone.js诞生。2011年React和Ember诞生。2014年Vue.js诞生……前后端分离可谓大势所趋。\n\n   后端只负责数据，前端负责其余工作，这种分工模式一定是更清晰也更高效的。随着基础设置的不断完善以及代码封装层级的不断提高，使得前端一个人能够完成的事越来越多，这是技术积累的必然结果。就好像今天高中生的知识水平，可能远远超过五百年前的科学家，今天要成为Web全栈工程师，门槛也只会越来越低。\n     ![Alt text](../img/4.png)\n     2014年，第五代HTML标准发布。H5是由浏览器厂商主导，与W3C合作制定的一整套Web应用规范，至今仍在不断补充新的草案。我们可以清晰的感受到这一系列规范背后隐含的领导者的勃勃雄心：占领所有屏幕。\n# 从前端走向全端\n   2009年Ryan Dahl发布了node，node是一个基于V8引擎的服务端JavaScript运行环境，类似于一个虚拟机，也就是说js在服务端语言中有了一席之地。如果说ajax是前端的第一次飞跃，那么node可算作前端的第二次飞跃。它意味着JavaScript走出了浏览器的藩篱，迈出了全端化的第一步。\n\n 一种流行的组合就是利用Express和Mongo搭建服务端程序。\n     ![Alt text](../img/5.png)\nWeb开疆拓土的步伐并不止于此。\n\n   2007年第一代iphone发布，2008年第一台安卓手机发布。悄然间互联网进入了移动时代。移动端的发展进程和PC的历史如出一辙，一开始都是Native App的天下。但浏览器试图取代操作系统的篡位之心从未消减。相比原生应用，Web APP有太多好处：无须开发两套系统版本、无须安装、无须手动升级、无须审核……我认为最大的好处以及驱动软件形态转向的主要原因在于降低成本，记得13年的时候韩寒说做一个APP大概需要五十万，今天网上比较靠谱的分析评估半年时间从零做出一个稍微像样的APP至少100万，而开发Web App花的钱一定少得多。\n\n   制约Web App的因素有很多，但我们可以看到Web App一直在不断修复缺陷、突破局限。你说网页有tab bar，好吧，给你个fullpage API，你说网页不能调取系统功能，好吧，Geolocation API、Vibration API、Luminosity API、Orientation API、Camera API……你说网页不像APP有图标，IOS早就支持在桌面上添加网页链接的快捷图标，还得是乔帮主远见；你说网页必须联网，现在离线的方案也很多啊；你说Web App性能差，这个……你说得对，也就是这个原因，Native App还能作为主流存在一段时间，可是如果Web App的性能逐渐赶上Native了呢？目前的Hybrid、nw.js、Electron、react native、weex等都可以看做Web App在性能方面向Native靠近的尝试。更何况半路又杀出个微信小程序。  \n\n\n\n\n     \n\n\n\n \n  \n\n \n\n\n  \n\n\n"},{"title":"项目中的注意事项","url":"/2018/05/18/项目中出现的问题/","content":"### 点赞效果\n```html\nhtml\n<span class=\"like_count\">\n    22\n</span>\n<span class=\" like like_img\">\n</span>\njavascript\nfunction userLike(){\n        $('body').on('click','.like',function () {\n            console.log('aaa')\n            var Num=$(this).siblings('.like_count').html()\n            if ($(this).is('.like_img')){\n                Num++\n                $(this).addClass(\"nolike_img\") .removeClass('like_img')\n                $(this).siblings('.like_count').html(Num)\n            }else {\n                Num--\n                $(this).addClass(\"like_img\") .removeClass('nolike_img')\n                $(this).siblings('.like_count').html(Num)\n            }\n        })\n    }\n```\n注意事项：<br/>\n(1)必须在span上添加like标签，不然会失去效果。\n(2)如果是诸如addclass removeClass这类的可以不添加类名的前缀，如果是is、siblings等的需要添加前缀，否则会失去效果。\n","tags":["items"]},{"title":"swiper在使用中需要注意的问题及解决方式","url":"/2018/05/18/swiper插件使用注意点/","content":"\n## 注意事项 \n    注意插件版本：4不能使用3的相关方法以及回调函数\n    设置swiper内容超出行向纵向滚动\n```html\n（必须项）设置swiper-slide的overflow属性\n.swiper-slide {  \n overflow: auto;  \n-webkit-overflow-scrolling: touch;   \n}\n```\n此外还需要引入js代码，否则会没有效果\n```js\n    var startScroll, touchStart, touchCurrent;\n    allSwiper.slides.on('touchstart', function (e) {\n        startScroll = this.scrollTop;\n        touchStart = e.targetTouches[0].pageY;\n    }, true);\n    allSwiper.slides.on('touchmove', function (e) {\n        touchCurrent = e.targetTouches[0].pageY;\n        var touchesDiff = touchCurrent - touchStart;\n        var slide = this;\n        var onlyScrolling =\n            ( slide.scrollHeight > slide.offsetHeight ) && //allow only when slide is scrollable\n            (\n                ( touchesDiff < 0 && startScroll === 0 ) || //start from top edge to scroll bottom\n                ( touchesDiff > 0 && startScroll === ( slide.scrollHeight - slide.offsetHeight ) ) || //start from bottom edge to scroll top\n                ( startScroll > 0 && startScroll < ( slide.scrollHeight - slide.offsetHeight ) ) //start from the middle\n            );\n        if (onlyScrolling) {\n            e.stopPropagation();\n        }\n    }, true);\n```\n\n\n## initialSlide：设定初始化时slide的索引。\n   也就是初次显示的位置\n## onSlidePrevEnd(swiper)\n   swiper切换结束执行的参数\n   \n ## onSlideNextStart(swiper)\n    回调函数，滑块释放时如果触发slider向前(右、下)切换则执行。类似于onSlideChangeStart，但规定了方向。\n    slider切换到下一张执行的参数\n\n## beforeDestroy()\n   回调函数，销毁Swiper时执行。\n\n","tags":["swiper"]}]